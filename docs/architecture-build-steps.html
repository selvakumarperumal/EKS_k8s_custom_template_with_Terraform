<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EKS Architecture Build Steps</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/dracula.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            background: #282a36;
            color: #f8f8f2;
            font-family: 'Segoe UI', system-ui, sans-serif;
            line-height: 1.7;
            padding: 2rem
        }

        .container {
            max-width: 1000px;
            margin: 0 auto
        }

        h1 {
            color: #bd93f9;
            font-size: 2.2rem;
            text-align: center;
            margin-bottom: .5rem;
            animation: glow 2s ease-in-out infinite alternate
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 5px #bd93f9
            }

            to {
                text-shadow: 0 0 20px #bd93f9, 0 0 40px #bd93f966
            }
        }

        .subtitle {
            color: #6272a4;
            text-align: center;
            margin-bottom: 3rem;
            font-size: 1.1rem
        }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, #bd93f9, #ff79c6, #50fa7b);
            z-index: 999;
            transition: width .3s
        }

        .phase {
            margin: 3rem 0;
            padding: 1.5rem;
            border-left: 4px solid #bd93f9;
            background: #1e1f29;
            border-radius: 0 8px 8px 0;
            opacity: 0;
            transform: translateY(30px);
            transition: all .6s ease
        }

        .phase.visible {
            opacity: 1;
            transform: translateY(0)
        }

        .phase h2 {
            color: #ff79c6;
            font-size: 1.5rem;
            margin-bottom: 1rem
        }

        .step {
            margin: 2rem 0;
            padding: 1.5rem;
            background: #44475a;
            border-radius: 8px;
            border: 1px solid #6272a4;
            opacity: 0;
            transform: translateX(-20px);
            transition: all .5s ease
        }

        .step.visible {
            opacity: 1;
            transform: translateX(0)
        }

        .step:hover {
            border-color: #bd93f9;
            box-shadow: 0 0 15px #bd93f933
        }

        .step h3 {
            color: #50fa7b;
            font-size: 1.2rem;
            margin-bottom: .8rem
        }

        .step h3 span {
            color: #6272a4;
            font-size: .9rem;
            font-weight: normal
        }

        .step .note {
            color: #f1fa8c;
            font-size: .9rem;
            margin-top: .8rem;
            padding: .5rem .8rem;
            background: #282a36;
            border-radius: 4px;
            border-left: 3px solid #f1fa8c
        }

        .step .explain {
            color: #f8f8f2;
            font-size: .9rem;
            margin-top: .8rem;
            padding: .8rem;
            background: #1e1f29;
            border-radius: 6px;
            border-left: 3px solid #8be9fd;
            line-height: 1.6
        }

        .step .explain strong {
            color: #ff79c6
        }

        .step .explain code {
            background: #44475a;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: .85rem
        }

        pre {
            background: #282a36 !important;
            border-radius: 6px;
            padding: 1rem !important;
            margin: .8rem 0;
            overflow-x: auto;
            border: 1px solid #6272a4
        }

        code {
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: .85rem
        }

        .d2-diagram {
            margin: 1rem 0;
            min-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #282a36;
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #6272a4;
            transition: all .8s ease
        }

        .d2-diagram.loaded {
            animation: diagramFadeIn .8s ease
        }

        @keyframes diagramFadeIn {
            from {
                opacity: 0;
                transform: scale(.95) translateY(10px)
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0)
            }
        }

        .d2-diagram.loading {
            color: #6272a4;
            font-style: italic
        }

        .d2-diagram svg {
            max-width: 100%;
            height: auto;
            transition: transform .4s ease
        }

        .d2-diagram:hover svg {
            transform: scale(1.02) translateY(-3px);
            filter: drop-shadow(0 8px 20px #bd93f933)
        }

        /* Animatic flowing data for all connection lines in D2 SVGs */
        @keyframes flowData {
            to {
                stroke-dashoffset: -16;
            }
        }

        .d2-diagram svg path[fill="none"][stroke]:not([stroke="none"]) {
            stroke-dasharray: 8 8 !important;
            animation: flowData 0.8s linear infinite;
        }

        /* Interactive nodes on hover inside SVG */
        .d2-diagram svg g {
            transform-origin: center;
            transition: transform 0.2s ease, filter 0.2s ease;
        }

        .d2-diagram svg g:hover {
            filter: drop-shadow(0 0 8px #bd93f988);
        }

        .d2-diagram:hover {
            border-color: #ff79c6;
            box-shadow: 0 0 20px #ff79c622
        }

        .summary {
            margin: 3rem 0;
            opacity: 0;
            transform: translateY(30px);
            transition: all .6s ease
        }

        .summary.visible {
            opacity: 1;
            transform: translateY(0)
        }

        .summary table {
            width: 100%;
            border-collapse: collapse;
            font-size: .9rem
        }

        .summary th {
            background: #bd93f9;
            color: #282a36;
            padding: .6rem;
            text-align: left
        }

        .summary td {
            padding: .5rem .6rem;
            border-bottom: 1px solid #44475a;
            transition: background .3s
        }

        .summary tr:hover {
            background: #44475a
        }

        .highlight-row td {
            color: #ff79c6;
            font-weight: bold
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: .75rem;
            font-weight: bold;
            transition: transform .2s
        }

        .badge:hover {
            transform: scale(1.1)
        }

        .badge-vpc {
            background: #50fa7b;
            color: #282a36
        }

        .badge-iam {
            background: #ff5555;
            color: #f8f8f2
        }

        .badge-eks {
            background: #ffb86c;
            color: #282a36
        }

        .badge-sec {
            background: #bd93f9;
            color: #282a36
        }

        .badge-sm {
            background: #f1fa8c;
            color: #282a36
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #bd93f9;
            color: #282a36;
            font-weight: bold;
            font-size: .8rem;
            margin-right: 8px
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="progress-bar" id="progressBar"></div>
        <h1>üèóÔ∏è Architecture Build Steps</h1>
        <p class="subtitle">How <code>terraform apply</code> builds the entire EKS infrastructure ‚Äî step by step</p>

        <div class="explain"
            style="margin-bottom: 3rem; background: #1e1f29; padding: 1.5rem; border-left: 4px solid #50fa7b; border-radius: 8px;">
            <h3 style="color: #50fa7b; margin-bottom: 0.5rem;">üèóÔ∏è Overall Architecture Summary</h3>
            This guide visually demonstrates the construction of a highly-available, production-ready Amazon EKS cluster
            over <strong>5 distinct phases</strong>:
            <ul style="margin-left: 1.5rem; margin-top: 0.5rem; color: #f8f8f2;">
                <li><strong>Phase 1 (VPC):</strong> Lays the network foundation across 3 Availability Zones with
                    isolated private subnets and secure outbound NAT routing.</li>
                <li><strong>Phase 2 (IAM):</strong> Establishes least-privilege, identity-based access roles for the EKS
                    control plane and EC2 worker nodes.</li>
                <li><strong>Phase 3 (EKS):</strong> Deploys the Kubernetes API servers, configures OIDC for per-pod
                    permissions (IRSA), and launches secure, IMDSv2-enforced worker nodes.</li>
                <li><strong>Phase 4 (Secrets):</strong> Sets up an independent, KMS-encrypted Secrets Manager vault for
                    application credentials and API keys.</li>
                <li><strong>Phase 5 (Security):</strong> Wraps the entire infrastructure in a continuous
                    threat-detection perimeter using GuardDuty and AWS Config.</li>
            </ul>
            <em>Scroll down to see the data flow in action ‚Äî the animated dashed lines represent network traffic and API
                calls between components!</em>
        </div>


        <div id="content"></div>

        <div class="summary">
            <h2 style="color:#bd93f9;margin-bottom:1rem">Build Summary</h2>
            <table>
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Resource</th>
                        <th>Module</th>
                        <th>Time</th>
                    </tr>
                </thead>
                <tbody id="summary-table"></tbody>
            </table>
        </div>
    </div>

    <script>
        const STEPS = [
            {
                phase: "Phase 1 ‚Äî VPC Module (Networking Foundation)", steps: [
                    {
                        title: "Create the VPC", module: "vpc", time: "~10s",
                        hcl: `resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true
  tags = merge(var.tags, { Name = "\${var.name_prefix}-vpc" })
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
vpc: VPC 10.0.0.0/16 {
  style.fill: "#44475a"
  style.stroke: "#bd93f9"
  dns: "DNS Support + Hostnames Enabled\\n65,536 IP addresses" {
    style.fill: "#50fa7b"; style.font-color: "#282a36"
  }
}`,
                        note: "enable_dns_support + enable_dns_hostnames are required by EKS ‚Äî kubelet uses DNS to register nodes.",
                        explain: "The VPC is your isolated private network in AWS. The <code>cidr_block</code> defines the IP range ‚Äî <strong>10.0.0.0/16</strong> gives 65,536 IP addresses. <strong>DNS support</strong> is critical: EKS nodes use internal DNS to discover the API server, and the VPC CNI plugin uses it to resolve AWS service endpoints. Without these flags, nodes fail to join the cluster."
                    },

                    {
                        title: "Attach Internet Gateway", module: "vpc", time: "~10s",
                        hcl: `resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id
  tags = merge(var.tags, { Name = "\${var.name_prefix}-igw" })
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
internet: Internet { shape: cloud; style.fill: "#6272a4" }
vpc: VPC 10.0.0.0/16 {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  igw: Internet Gateway { style.fill: "#ffb86c"; style.font-color: "#282a36" }
}
internet <-> vpc.igw: Bidirectional { style.stroke: "#8be9fd" }`,
                        note: "One IGW per VPC ‚Äî the front door. Only public subnets use it.",
                        explain: "The Internet Gateway is a horizontally-scaled, redundant AWS-managed component. It performs <strong>1:1 NAT</strong> for instances with public IPs. Without it, nothing in your VPC can reach the internet. You only ever need <strong>one per VPC</strong>."
                    },

                    {
                        title: "Create Public Subnets (√ó3)", module: "vpc", time: "~15s",
                        hcl: `resource "aws_subnet" "public" {
  count                   = length(var.public_subnets)
  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.public_subnets[count.index]
  availability_zone       = var.azs[count.index]
  map_public_ip_on_launch = true
  tags = merge(var.tags, var.public_subnet_tags, {
    Name = ",
                        explain:"Public subnets are spread across <strong>3 Availability Zones</strong> for fault tolerance. The <code>count</code> loop creates one subnet per AZ. The EKS tag <code>kubernetes.io/role/elb</code> tells the AWS Load Balancer Controller to place public-facing ALBs in these subnets."\${var.name_prefix}-public-\${var.azs[count.index]}"
  })
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
internet: Internet { shape: cloud; style.fill: "#6272a4" }
vpc: VPC {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  igw: IGW { style.fill: "#ffb86c"; style.font-color: "#282a36" }
  az1: AZ-A {
    style.fill: "#282a36"; style.stroke: "#6272a4"
    pub1: "Public 10.0.101.0/24" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
  }
  az2: AZ-B {
    style.fill: "#282a36"; style.stroke: "#6272a4"
    pub2: "Public 10.0.102.0/24" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
  }
  az3: AZ-C {
    style.fill: "#282a36"; style.stroke: "#6272a4"
    pub3: "Public 10.0.103.0/24" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
  }
}
internet <-> vpc.igw
vpc.igw <-> vpc.az1.pub1
vpc.igw <-> vpc.az2.pub2
vpc.igw <-> vpc.az3.pub3`,
                        note: "map_public_ip_on_launch = true. Tagged kubernetes.io/role/elb = 1 for ALB discovery."
                    },

                    {
                        title: "Create Private Subnets (√ó3)", module: "vpc", time: "~15s",
                        hcl: `resource "aws_subnet" "private" {
  count             = length(var.private_subnets)
  vpc_id            = aws_vpc.main.id
  cidr_block        = var.private_subnets[count.index]
  availability_zone = var.azs[count.index]
  tags = merge(var.tags, var.private_subnet_tags, {
    Name = "\${var.name_prefix}-private-\${var.azs[count.index]}"
  })
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
vpc: VPC {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  az1: AZ-A {
    style.fill: "#282a36"; style.stroke: "#6272a4"
    pub1: "Public" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
    priv1: "Private 10.0.1.0/24" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
  }
  az2: AZ-B {
    style.fill: "#282a36"; style.stroke: "#6272a4"
    pub2: "Public" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
    priv2: "Private 10.0.2.0/24" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
  }
  az3: AZ-C {
    style.fill: "#282a36"; style.stroke: "#6272a4"
    pub3: "Public" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
    priv3: "Private 10.0.3.0/24" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
  }
}`,
                        note: "No public IPs. EKS worker nodes live here. Tagged kubernetes.io/role/internal-elb = 1.",
                        explain: "Private subnets have <strong>no route to the Internet Gateway</strong> ‚Äî they are completely isolated. Worker nodes here can only reach the internet through the NAT Gateway. The tag <code>kubernetes.io/role/internal-elb</code> tells EKS to place internal NLBs here for service-to-service communication."
                    },

                    {
                        title: "Create EIP + NAT Gateway", module: "vpc", time: "~2m",
                        hcl: `resource "aws_eip" "nat" {
  count  = var.enable_nat_gateway ? (var.single_nat_gateway ? 1 : length(var.public_subnets)) : 0
  domain = "vpc"
  depends_on = [aws_internet_gateway.main]
}

resource "aws_nat_gateway" "main" {
  count         = var.enable_nat_gateway ? (var.single_nat_gateway ? 1 : length(var.public_subnets)) : 0
  allocation_id = aws_eip.nat[count.index].id
  subnet_id     = aws_subnet.public[count.index].id
  depends_on    = [aws_internet_gateway.main]
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
internet: Internet { shape: cloud; style.fill: "#6272a4" }
vpc: VPC {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  igw: IGW { style.fill: "#ffb86c"; style.font-color: "#282a36" }
  nat: "NAT Gateway + Elastic IP" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
  priv1: Private Subnet { style.fill: "#8be9fd"; style.font-color: "#282a36" }
  priv2: Private Subnet { style.fill: "#8be9fd"; style.font-color: "#282a36" }
}
internet <-> vpc.igw
vpc.nat -> vpc.igw
vpc.priv1 -> vpc.nat: "Outbound only" { style.stroke: "#f1fa8c" }
vpc.priv2 -> vpc.nat: "Outbound only" { style.stroke: "#f1fa8c" }`,
                        note: "single_nat_gateway = true ‚Üí 1 NAT (~$33/mo). Set false for HA (1 per AZ, ~$100/mo).",
                        explain: "The NAT Gateway translates private IPs to a public Elastic IP for outbound traffic. The <code>count</code> ternary handles two modes: <strong>single NAT</strong> (cheaper, single AZ) or <strong>multi-AZ NAT</strong> (one per AZ for HA). In production, use multi-AZ so private subnets survive an AZ failure."
                    },

                    {
                        title: "Create Route Tables", module: "vpc", time: "~10s",
                        hcl: `resource "aws_route" "public_internet_gateway" {
  route_table_id         = aws_route_table.public.id
  destination_cidr_block = "0.0.0.0/0"
  gateway_id             = aws_internet_gateway.main.id
}

resource "aws_route" "private_nat_gateway" {
  count                  = var.enable_nat_gateway ? (var.single_nat_gateway ? 1 : length(var.private_subnets)) : 0
  route_table_id         = aws_route_table.private[count.index].id
  destination_cidr_block = "0.0.0.0/0"
  nat_gateway_id         = aws_nat_gateway.main[count.index].id
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
pub_rt: "Public Route Table\\n0.0.0.0/0 ‚Üí IGW" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
igw: IGW { style.fill: "#ffb86c"; style.font-color: "#282a36" }
priv_rt: "Private Route Table\\n0.0.0.0/0 ‚Üí NAT" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
nat: NAT { style.fill: "#ffb86c"; style.font-color: "#282a36" }
pub_rt -> igw: "Direct internet" { style.stroke: "#50fa7b" }
priv_rt -> nat: "Outbound only" { style.stroke: "#f1fa8c" }`,
                        note: "Public ‚Üí IGW (direct). Private ‚Üí NAT (outbound only)."
                    },

                    {
                        title: "Create Public NACL", module: "vpc", time: "~10s",
                        hcl: `resource "aws_network_acl" "public" {
  vpc_id     = aws_vpc.main.id
  subnet_ids = aws_subnet.public[*].id
  ingress { rule_no=100; protocol="tcp"; action="allow"; cidr_block="0.0.0.0/0"; from_port=443; to_port=443 }
  ingress { rule_no=200; protocol="tcp"; action="allow"; cidr_block="0.0.0.0/0"; from_port=80; to_port=80 }
  ingress { rule_no=300; protocol="tcp"; action="allow"; cidr_block="0.0.0.0/0"; from_port=1024; to_port=65535 }
  ingress { rule_no=400; protocol="-1"; action="allow"; cidr_block=var.vpc_cidr; from_port=0; to_port=0 }
  egress  { rule_no=100; protocol="-1"; action="allow"; cidr_block="0.0.0.0/0"; from_port=0; to_port=0 }
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
nacl: "Public NACL" {
  style.fill: "#bd93f9"; style.font-color: "#f8f8f2"
  r1: "Rule 100: HTTPS 443" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
  r2: "Rule 200: HTTP 80" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
  r3: "Rule 300: Ephemeral 1024-65535" { style.fill: "#f1fa8c"; style.font-color: "#282a36" }
  r4: "Rule 400: VPC Internal" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
}
subnets: "Public Subnets x3" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
nacl -- subnets: Applied { style.stroke: "#ff79c6" }`,
                        note: "NACLs are stateless ‚Äî Rule 300 allows ephemeral response ports.",
                        explain: "NACLs operate at the <strong>subnet level</strong> and are <strong>stateless</strong> ‚Äî unlike Security Groups which are stateful. This means you must explicitly allow both <strong>request AND response</strong> traffic. Rule 300 (ephemeral ports 1024-65535) allows response packets from outbound connections. Rules are evaluated in <strong>numeric order</strong> ‚Äî lowest number wins."
                    },

                    {
                        title: "Create Private NACL", module: "vpc", time: "~10s",
                        hcl: `resource "aws_network_acl" "private" {
  vpc_id     = aws_vpc.main.id
  subnet_ids = aws_subnet.private[*].id
  ingress { rule_no=100; protocol="-1"; action="allow"; cidr_block=var.vpc_cidr; from_port=0; to_port=0 }
  ingress { rule_no=200; protocol="tcp"; action="allow"; cidr_block="0.0.0.0/0"; from_port=1024; to_port=65535 }
  egress  { rule_no=100; protocol="-1"; action="allow"; cidr_block="0.0.0.0/0"; from_port=0; to_port=0 }
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
nacl: "Private NACL" {
  style.fill: "#bd93f9"; style.font-color: "#f8f8f2"
  r1: "Rule 100: VPC Internal ONLY" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
  r2: "Rule 200: Ephemeral ports" { style.fill: "#f1fa8c"; style.font-color: "#282a36" }
}
subnets: "Private Subnets x3" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
nacl -- subnets: Applied { style.stroke: "#ff79c6" }`,
                        note: "More restrictive ‚Äî only VPC-internal + ephemeral ports allowed inbound.",
                        explain: "Private NACLs only allow traffic originating from <strong>within the VPC</strong> (10.0.0.0/16). No external traffic can reach private subnets directly. The ephemeral port rule allows <strong>return traffic</strong> from NAT Gateway outbound connections (like pulling Docker images)."
                    },

                    {
                        title: "Enable VPC Flow Logs", module: "vpc", time: "~15s",
                        hcl: `resource "aws_flow_log" "main" {
  count        = var.enable_flow_logs ? 1 : 0
  vpc_id       = aws_vpc.main.id
  traffic_type = "ALL"
  iam_role_arn    = aws_iam_role.flow_log[0].arn
  log_destination = aws_cloudwatch_log_group.flow_log[0].arn
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
vpc: VPC { style.fill: "#44475a"; style.stroke: "#bd93f9"
  traffic: "All Network Traffic" { style.fill: "#6272a4"; style.font-color: "#f8f8f2" }
}
flow: "VPC Flow Logs" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
cw: "CloudWatch\\nRetention: 30 days" { style.fill: "#6272a4"; style.font-color: "#f8f8f2" }
vpc.traffic -> flow: "Src/Dst IP, Port\\nACCEPT/REJECT" { style.stroke: "#8be9fd" }
flow -> cw { style.stroke: "#8be9fd" }`,
                        note: "traffic_type = ALL captures accepted + rejected traffic for forensic analysis.",
                        explain: "VPC Flow Logs capture metadata about every network connection: <strong>source/destination IP</strong>, <strong>port</strong>, <strong>protocol</strong>, and whether it was <strong>ACCEPTED or REJECTED</strong>. This is essential for security forensics, troubleshooting connectivity issues, and compliance auditing. Retained for 30 days in CloudWatch (~$5/mo)."
                    },
                ]
            },

            {
                phase: "Phase 2 ‚Äî IAM Module (Parallel with VPC)", steps: [
                    {
                        title: "Create Cluster IAM Role", module: "iam", time: "~15s",
                        hcl: `resource "aws_iam_role" "cluster" {
  name_prefix = "\${var.cluster_name}-cluster-"
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{ Action = "sts:AssumeRole"; Effect = "Allow"
      Principal = { Service = "eks.amazonaws.com" } }]
  })
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
role: "Cluster IAM Role" {
  style.fill: "#ff5555"; style.font-color: "#f8f8f2"
  trust: "Trust: eks.amazonaws.com" { style.fill: "#44475a"; style.font-color: "#f8f8f2" }
}
p1: "AmazonEKSClusterPolicy" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
p2: "AmazonEKSVPCResourceController" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
role -> p1: Attached { style.stroke: "#f1fa8c" }
role -> p2: Attached { style.stroke: "#f1fa8c" }`,
                        note: "Only eks.amazonaws.com can assume this role ‚Äî not humans, not Lambda.",
                        explain: "IAM roles have two parts: the <strong>trust policy</strong> (who can assume the role) and the <strong>permissions policies</strong> (what the role can do). The trust policy locks this role to the EKS service. <code>AmazonEKSClusterPolicy</code> lets EKS manage ENIs and describe resources. <code>VPCResourceController</code> enables the VPC CNI to manage network interfaces."
                    },

                    {
                        title: "Create Node Group IAM Role", module: "iam", time: "~15s",
                        hcl: `resource "aws_iam_role" "node_group" {
  name_prefix = "\${var.cluster_name}-node-"
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{ Action = "sts:AssumeRole"; Effect = "Allow"
      Principal = { Service = "ec2.amazonaws.com" } }]
  })
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
role: "Node Group IAM Role" {
  style.fill: "#ff5555"; style.font-color: "#f8f8f2"
  trust: "Trust: ec2.amazonaws.com" { style.fill: "#44475a"; style.font-color: "#f8f8f2" }
}
p1: "EKSWorkerNodePolicy" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
p2: "EKS_CNI_Policy" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
p3: "ECR ReadOnly" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
role -> p1 { style.stroke: "#f1fa8c" }
role -> p2 { style.stroke: "#f1fa8c" }
role -> p3 { style.stroke: "#f1fa8c" }`,
                        note: "Without WorkerNodePolicy ‚Üí NotReady. Without ECR ReadOnly ‚Üí no basic auth credentials.",
                        explain: "Worker nodes need three capabilities: <strong>register with EKS</strong> (WorkerNodePolicy), <strong>assign pod IPs</strong> (CNI Policy), and <strong>pull container images</strong> (ECR ReadOnly). Each policy follows least privilege ‚Äî nodes can only read from ECR, not push. For tighter security, move the CNI policy to the aws-node ServiceAccount via IRSA."
                    },
                ]
            },

            {
                phase: "Phase 3 ‚Äî EKS Module (Needs VPC + IAM)", steps: [
                    {
                        title: "Create KMS Key", module: "eks", time: "~10s",
                        hcl: `resource "aws_kms_key" "eks" {
  description             = "KMS key for EKS cluster \${var.cluster_name} encryption"
  deletion_window_in_days = 7
  enable_key_rotation     = true
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
kms: "KMS Master Key" { style.fill: "#ff5555"; style.font-color: "#f8f8f2" }
secret: "K8s Secret" { style.fill: "#44475a"; style.font-color: "#f8f8f2" }
dek: "Data Encryption Key" { style.fill: "#f1fa8c"; style.font-color: "#282a36" }
etcd: etcd { shape: cylinder; style.fill: "#ff5555"; style.font-color: "#f8f8f2" }
secret -> dek: "1. Generate DEK"
dek -> etcd: "2. Encrypt secret"
kms -> dek: "3. Encrypt DEK" { style.stroke: "#ff79c6" }`,
                        note: "Envelope encryption: KMS encrypts the DEK, not the secret directly.",
                        explain: "Without KMS, Kubernetes secrets in etcd are just <strong>base64 encoded</strong> (easily decoded). With envelope encryption, each secret gets a unique <strong>Data Encryption Key (DEK)</strong>, and the KMS master key encrypts the DEK. Even if someone accesses etcd directly, they can not decrypt secrets without the KMS key. <code>enable_key_rotation</code> rotates the key annually.",
                        explain: "Route tables are the traffic rules. <code>0.0.0.0/0</code> is the default route ‚Äî it catches all traffic not destined for within the VPC. Public subnets send it to the IGW. Private subnets send it to the NAT. The <code>aws_route_table_association</code> links each subnet to its route table."
                    },

                    {
                        title: "Create Security Groups + Rules", module: "eks", time: "~15s",
                        hcl: `resource "aws_security_group_rule" "node_to_cluster" {
  type = "ingress"; from_port = 443; to_port = 443; protocol = "tcp"
  security_group_id        = aws_security_group.cluster.id
  source_security_group_id = aws_security_group.node.id
}
resource "aws_security_group_rule" "cluster_to_node" {
  type = "ingress"; from_port = 1025; to_port = 65535; protocol = "tcp"
  security_group_id        = aws_security_group.node.id
  source_security_group_id = aws_security_group.cluster.id
}
resource "aws_security_group_rule" "node_to_node" {
  type = "ingress"; from_port = 0; to_port = 65535; protocol = "-1"
  security_group_id = aws_security_group.node.id; self = true
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
csg: "Cluster SG\\nControl Plane" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
nsg: "Node SG\\nWorkers" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
nsg -> csg: "Port 443\\nkubelet ‚Üí API" { style.stroke: "#50fa7b" }
csg -> nsg: "Port 1025-65535\\nkubectl exec" { style.stroke: "#8be9fd" }
nsg -> nsg: "All ports\\npod-to-pod" { style.stroke: "#f1fa8c" }`,
                        note: "self = true allows node-to-node traffic on all ports.",
                        explain: "Three rules define all cluster communication: <strong>Nodes ‚Üí API (443)</strong> for kubelet heartbeats and pod status. <strong>API ‚Üí Nodes (1025-65535)</strong> for kubectl exec, logs, and port-forward. <strong>Node ‚Üí Node (all)</strong> for pod-to-pod networking, CoreDNS queries, and metrics scraping. <code>self = true</code> means the SG references itself."
                    },

                    {
                        title: "Create EKS Cluster (~10 min)", module: "eks", time: "~10m", highlight: true,
                        hcl: `resource "aws_eks_cluster" "main" {
  name     = var.cluster_name
  version  = var.kubernetes_version
  role_arn = var.cluster_role_arn
  vpc_config {
    subnet_ids              = var.subnet_ids
    endpoint_public_access  = var.endpoint_public_access
    endpoint_private_access = var.endpoint_private_access
    security_group_ids      = [aws_security_group.cluster.id]
  }
  encryption_config {
    provider { key_arn = aws_kms_key.eks.arn }
    resources = ["secrets"]
  }
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
admin: kubectl { shape: person; style.fill: "#6272a4" }
aws: "AWS-Managed VPC" {
  style.fill: "#44475a"; style.stroke: "#6272a4"
  cp: "EKS Control Plane" {
    style.fill: "#282a36"; style.stroke: "#ffb86c"
    api: "API Server x3 AZs" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
    etcd: "etcd (KMS encrypted)" { shape: cylinder; style.fill: "#ff5555"; style.font-color: "#f8f8f2" }
    api <-> etcd
  }
}
customer: "Customer VPC" {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  eni: "EKS-managed ENIs\\nin Private Subnets" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
}
admin -> aws.cp.api: "HTTPS :443" { style.stroke: "#50fa7b" }
aws.cp.api <-> customer.eni: "Private Link" { style.stroke: "#ff79c6" }`,
                        note: "The longest step (~10 min). AWS provisions 3 redundant API servers across 3 AZs.",
                        explain: "AWS creates the control plane in their own VPC with <strong>3 redundant API servers</strong> across 3 AZs. It injects <strong>ENIs into your private subnets</strong> so nodes can reach the API privately. <code>encryption_config</code> encrypts all Kubernetes Secrets at rest. The 5 log types cover API calls, authentication, scheduling, and controller decisions."
                    },

                    {
                        title: "Register OIDC Provider (IRSA)", module: "eks", time: "~10s",
                        hcl: `resource "aws_iam_openid_connect_provider" "cluster" {
  count           = var.enable_irsa ? 1 : 0
  client_id_list  = ["sts.amazonaws.com"]
  thumbprint_list = [data.tls_certificate.cluster[0].certificates[0].sha1_fingerprint]
  url             = aws_eks_cluster.main.identity[0].oidc[0].issuer
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
oidc: "OIDC Provider in IAM" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
pods: "Per-Pod Permissions" {
  style.fill: "#282a36"; style.stroke: "#6272a4"
  a: "Pod A ‚Üí S3 ReadOnly" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
  b: "Pod B ‚Üí DynamoDB Write" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
}
oidc -> pods: "ServiceAccount ‚Üí IAM Role" { style.stroke: "#50fa7b"; style.stroke-dash: 5 }`,
                        note: "Without IRSA all pods share the Node Role. With IRSA each pod gets least-privilege IAM.",
                        explain: "IRSA maps a Kubernetes <strong>ServiceAccount</strong> to an <strong>IAM Role</strong> via OIDC federation. When a pod uses that ServiceAccount, AWS STS exchanges the K8s token for temporary IAM credentials. This eliminates the need for access keys in pods. The TLS thumbprint verifies the OIDC issuer identity."
                    },

                    {
                        title: "Install EKS Add-ons", module: "eks", time: "~2m",
                        hcl: `resource "aws_eks_addon" "vpc_cni"    { cluster_name = aws_eks_cluster.main.name; addon_name = "vpc-cni" }
resource "aws_eks_addon" "kube_proxy"  { cluster_name = aws_eks_cluster.main.name; addon_name = "kube-proxy" }
resource "aws_eks_addon" "coredns"     { cluster_name = aws_eks_cluster.main.name; addon_name = "coredns"
  depends_on = [aws_eks_node_group.main] }`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
addons: "EKS Add-ons" {
  style.fill: "#282a36"; style.stroke: "#6272a4"
  cni: "VPC CNI: real VPC IPs for pods" { style.fill: "#795548"; style.font-color: "#f8f8f2" }
  kp: "kube-proxy: Service iptables" { style.fill: "#795548"; style.font-color: "#f8f8f2" }
  dns: "CoreDNS: DNS resolution (needs nodes)" { style.fill: "#795548"; style.font-color: "#f8f8f2" }
}`,
                        note: "CoreDNS depends_on node groups ‚Äî it needs nodes to schedule its pods.",
                        explain: "<strong>VPC CNI</strong> runs as a DaemonSet ‚Äî assigns real VPC IPs to pods (no overlay network). <strong>kube-proxy</strong> manages iptables/IPVS rules for Service routing. <strong>CoreDNS</strong> resolves DNS names (my-svc.namespace.svc.cluster.local ‚Üí ClusterIP). CoreDNS is a Deployment and needs at least one running node ‚Äî hence the depends_on."
                    },

                    {
                        title: "Create Launch Templates", module: "eks", time: "~10s",
                        hcl: `resource "aws_launch_template" "node" {
  for_each = var.node_groups
  metadata_options {
    http_tokens = "required"  # IMDSv2 enforced
    http_put_response_hop_limit = 2
  }
  block_device_mappings {
    ebs { volume_type = "gp3"; encrypted = true; iops = 3000 }
  }
  network_interfaces { associate_public_ip_address = false }
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
lt: "Launch Template" {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  imds: "IMDSv2 Enforced (blocks SSRF)" { style.fill: "#ff5555"; style.font-color: "#f8f8f2" }
  ebs: "gp3 Encrypted, 3000 IOPS" { style.fill: "#6272a4"; style.font-color: "#f8f8f2" }
  noip: "No Public IP" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
  sg: "Node Security Group" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
}`,
                        note: "http_tokens = required prevents SSRF credential theft (Capital One breach used IMDSv1).",
                        explain: "Launch templates define the <strong>security baseline</strong> for all nodes. <code>http_tokens = required</code> enforces IMDSv2, preventing SSRF attacks that steal credentials from the metadata endpoint. <code>hop_limit = 2</code> is needed because containers are 2 network hops from the metadata service. <code>gp3</code> volumes provide 3000 baseline IOPS with encryption at rest."
                    },

                    {
                        title: "Create Node Groups", module: "eks", time: "~3m",
                        hcl: `resource "aws_eks_node_group" "main" {
  for_each     = var.node_groups
  cluster_name = aws_eks_cluster.main.name
  node_role_arn = var.node_role_arn
  subnet_ids    = var.subnet_ids
  scaling_config {
    desired_size = each.value.desired_size
    max_size = each.value.max_size; min_size = each.value.min_size
  }
  capacity_type = lookup(each.value, "capacity_type", "ON_DEMAND")
  depends_on = [aws_eks_addon.vpc_cni, aws_eks_addon.kube_proxy]
  lifecycle { ignore_changes = [scaling_config[0].desired_size] }
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
vpc: "Customer VPC" {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  cp: "Control Plane" { style.fill: "#282a36"; style.stroke: "#ffb86c"
    api: "API Server" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
  }
  priv: "Private Subnets" { style.fill: "#282a36"; style.stroke: "#8be9fd"
    g1: "t3.medium ON_DEMAND" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
    g2: "t3.medium ON_DEMAND" { style.fill: "#8be9fd"; style.font-color: "#282a36" }
    s1: "t3.medium SPOT 90% off" { style.fill: "#f1fa8c"; style.font-color: "#282a36" }
  }
}
vpc.cp.api -> vpc.priv.g1: "443" { style.stroke: "#50fa7b" }
vpc.cp.api -> vpc.priv.g2: "443" { style.stroke: "#50fa7b" }
vpc.cp.api -> vpc.priv.s1: "443" { style.stroke: "#50fa7b" }`,
                        note: "ignore_changes = [desired_size] prevents Terraform from fighting the Cluster Autoscaler.",
                        explain: "Two node groups serve different purposes: <strong>General (ON_DEMAND)</strong> for reliable, always-available workloads, and <strong>Spot (up to 90% off)</strong> for fault-tolerant batch jobs. Spot nodes have a <strong>taint</strong> that prevents pods from scheduling there unless they explicitly tolerate it. <code>lifecycle { ignore_changes }</code> prevents Terraform from overriding autoscaler decisions."
                    },
                ]
            },

            {
                phase: "Phase 4 ‚Äî Secrets Manager Module", steps: [
                    {
                        title: "Create Secrets + KMS Key", module: "sm", time: "~30s",
                        hcl: `resource "aws_kms_key" "secrets" {
  count = var.create_db_secret || var.create_api_secret || var.create_app_config_secret ? 1 : 0
  enable_key_rotation = true
}
resource "aws_secretsmanager_secret" "db_credentials" {
  count      = var.create_db_secret ? 1 : 0
  kms_key_id = aws_kms_key.secrets[0].id
  recovery_window_in_days = 7
}`,
                        d2: `direction: right
vars: { d2-config: { theme-id: 200 } }
sm: "Secrets Manager" {
  style.fill: "#44475a"; style.stroke: "#ffb86c"
  kms: "Dedicated KMS Key" { style.fill: "#ff5555"; style.font-color: "#f8f8f2" }
  db: "DB Credentials" { style.fill: "#f1fa8c"; style.font-color: "#282a36" }
  api: "API Keys" { style.fill: "#f1fa8c"; style.font-color: "#282a36" }
  app: "App Config" { style.fill: "#f1fa8c"; style.font-color: "#282a36" }
  kms -> db: encrypts { style.stroke: "#ff79c6"; style.stroke-dash: 3 }
  kms -> api: encrypts { style.stroke: "#ff79c6"; style.stroke-dash: 3 }
  kms -> app: encrypts { style.stroke: "#ff79c6"; style.stroke-dash: 3 }
}`,
                        note: "Separate KMS key from EKS ‚Äî different blast radius if compromised.",
                        explain: "A <strong>dedicated KMS key</strong> for Secrets Manager means it has separate access policies from the EKS key. If one key is compromised, the other remains safe. Secrets are conditionally created using <code>count</code> flags. <code>recovery_window_in_days = 7</code> prevents accidental permanent deletion ‚Äî you have 7 days to recover."
                    },

                    {
                        title: "Create Read-Only IAM Policy", module: "sm", time: "~5s",
                        hcl: `resource "aws_iam_policy" "read_secrets" {
  policy = jsonencode({
    Statement = [
      { Action = ["secretsmanager:GetSecretValue","secretsmanager:DescribeSecret"]
        Resource = concat(
          var.create_db_secret ? [aws_secretsmanager_secret.db_credentials[0].arn] : [],
          var.create_api_secret ? [aws_secretsmanager_secret.api_keys[0].arn] : []
        ) },
      { Action = ["kms:Decrypt","kms:DescribeKey"]
        Resource = [aws_kms_key.secrets[0].arn] }
    ]
  })
}`,
                        d2: ``,
                        note: "Only specific secret ARNs (no wildcards). kms:Decrypt required to read encrypted values.",
                        explain: "The IAM policy uses <code>concat()</code> to dynamically build the list of allowed secret ARNs based on which secrets were actually created. No wildcards ‚Äî pods can only read <strong>their specific secrets</strong>. <code>kms:Decrypt</code> is required because the secrets are encrypted with the dedicated KMS key."
                    },
                ]
            },

            {
                phase: "Phase 5 ‚Äî Security Module", steps: [
                    {
                        title: "Enable GuardDuty", module: "sec", time: "~30s",
                        hcl: `resource "aws_guardduty_detector" "main" {
  count  = var.enable_guardduty ? 1 : 0
  enable = true
  finding_publishing_frequency = "FIFTEEN_MINUTES"
}
resource "aws_guardduty_detector_feature" "eks_audit_logs" {
  detector_id = aws_guardduty_detector.main[0].id
  name = "EKS_AUDIT_LOGS"; status = "ENABLED"
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
sources: "Data Sources" {
  style.fill: "#282a36"; style.stroke: "#6272a4"
  vfl: "VPC Flow Logs" { style.fill: "#6272a4"; style.font-color: "#f8f8f2" }
  k8s: "EKS Audit Logs" { style.fill: "#6272a4"; style.font-color: "#f8f8f2" }
}
gd: "GuardDuty" {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  det: Detector { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
  eks: "EKS Audit Analysis" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
  rt: "Runtime Monitoring" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
  mal: "Malware Protection" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
  det -> eks
  det -> rt
  det -> mal
}
alert: "Security Alerts" { style.fill: "#ff5555"; style.font-color: "#f8f8f2" }
sources.vfl -> gd.det { style.stroke: "#8be9fd" }
sources.k8s -> gd.det { style.stroke: "#8be9fd" }
gd.det -> alert { style.stroke: "#ff5555" }`,
                        note: "Detects crypto mining, compromised creds, unauthorized API calls, privilege escalation.",
                        explain: "GuardDuty analyzes <strong>VPC Flow Logs, CloudTrail, DNS queries</strong>, and <strong>EKS audit logs</strong> using ML and threat intelligence. It detects patterns like cryptocurrency mining, port scanning, data exfiltration, and compromised IAM credentials. <code>finding_publishing_frequency = FIFTEEN_MINUTES</code> means findings are updated every 15 minutes. Cost is based on data volume analyzed (~$5-15/mo for small clusters)."
                    },

                    {
                        title: "Enable AWS Config Rules", module: "sec", time: "~15s",
                        hcl: `resource "aws_config_config_rule" "eks_cluster_logging" {
  name = "\${var.cluster_name}-eks-logging-enabled"
  source { owner = "AWS"; source_identifier = "EKS_CLUSTER_LOGGING_ENABLED" }
  scope { compliance_resource_types = ["AWS::EKS::Cluster"] }
}
resource "aws_config_config_rule" "eks_secrets_encrypted" {
  name = "\${var.cluster_name}-eks-secrets-encrypted"
  source { owner = "AWS"; source_identifier = "EKS_SECRETS_ENCRYPTED" }
}`,
                        d2: `direction: down
vars: { d2-config: { theme-id: 200 } }
config: "AWS Config" {
  style.fill: "#44475a"; style.stroke: "#bd93f9"
  rec: "Config Recorder" { style.fill: "#6272a4"; style.font-color: "#f8f8f2" }
  r1: "EKS Logging?" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
  r2: "No Public Endpoint?" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
  r3: "Secrets Encrypted?" { style.fill: "#bd93f9"; style.font-color: "#f8f8f2" }
  rec -> r1
  rec -> r2
  rec -> r3
}
c1: "COMPLIANT" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
c2: "NON_COMPLIANT (dev OK)" { style.fill: "#ffb86c"; style.font-color: "#282a36" }
c3: "COMPLIANT" { style.fill: "#50fa7b"; style.font-color: "#282a36" }
config.r1 -> c1 { style.stroke: "#50fa7b" }
config.r2 -> c2 { style.stroke: "#ffb86c" }
config.r3 -> c3 { style.stroke: "#50fa7b" }`,
                        note: "Config continuously monitors resource configurations against security rules.",
                        explain: "AWS Config takes a <strong>continuous snapshot</strong> of all resource configurations and evaluates them against rules. The three EKS rules check: is control plane logging enabled? Is the API endpoint private? Are secrets encrypted with KMS? Non-compliant resources are flagged but <strong>not automatically remediated</strong> ‚Äî you decide what to fix."
                    },
                ]
            },
        ];

        const BADGES = { vpc: 'badge-vpc', iam: 'badge-iam', eks: 'badge-eks', sec: 'badge-sec', sm: 'badge-sm' };
        const BADGE_LABEL = { vpc: 'VPC', iam: 'IAM', eks: 'EKS', sec: 'Security', sm: 'Secrets' };

        // Render
        let html = '', stepNum = 0, summaryRows = '';
        STEPS.forEach(phase => {
            html += `<div class="phase"><h2>${phase.phase}</h2>`;
            phase.steps.forEach(s => {
                stepNum++;
                html += `<div class="step"><h3>Step ${stepNum} ‚Äî ${s.title} <span><span class="badge ${BADGES[s.module]}">${BADGE_LABEL[s.module]}</span> ${s.time}</span></h3>`;
                html += `<pre><code class="language-hcl">${escHtml(s.hcl)}</code></pre>`;
                if (s.d2) html += `<div class="d2-diagram loading" data-d2="${btoa(unescape(encodeURIComponent(s.d2)))}">Loading diagram...</div>`;
                if (s.explain) html += `<div class="explain">${s.explain}</div>`;
                if (s.note) html += `<div class="note">üí° ${s.note}</div>`;
                html += `</div>`;
                summaryRows += `<tr class="${s.highlight ? 'highlight-row' : ''}"><td>${stepNum}</td><td>${s.title}</td><td><span class="badge ${BADGES[s.module]}">${BADGE_LABEL[s.module]}</span></td><td>${s.time}</td></tr>`;
            });
            html += `</div>`;
        });
        summaryRows += `<tr class="highlight-row"><td></td><td><strong>Total: ~50 resources</strong></td><td></td><td><strong>~20 min</strong></td></tr>`;

        document.getElementById('content').innerHTML = html;
        document.getElementById('summary-table').innerHTML = summaryRows;

        function escHtml(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

        // Highlight code
        hljs.highlightAll();

        // Render D2 diagrams via Kroki
        document.querySelectorAll('.d2-diagram[data-d2]').forEach(el => {
            const src = decodeURIComponent(escape(atob(el.dataset.d2)));
            fetch('https://kroki.io/d2/svg', { method: 'POST', headers: { 'Content-Type': 'text/plain' }, body: src })
                .then(r => { if (!r.ok) throw new Error(r.status); return r.text() })
                .then(svg => { el.innerHTML = svg; el.classList.remove('loading'); el.classList.add('loaded') })
                .catch(e => { el.innerHTML = `<span style="color:#ff5555">Diagram failed: ${e.message}</span>`; el.classList.remove('loading') });
        });

        // Scroll-triggered animations
        const observer = new IntersectionObserver((entries) => {
            entries.forEach((entry, i) => {
                if (entry.isIntersecting) {
                    setTimeout(() => entry.target.classList.add('visible'), i * 100);
                    observer.unobserve(entry.target);
                }
            });
        }, { threshold: 0.1 });
        document.querySelectorAll('.phase, .step, .summary').forEach(el => observer.observe(el));

        // Progress bar
        window.addEventListener('scroll', () => {
            const h = document.documentElement;
            const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
            document.getElementById('progressBar').style.width = pct + '%';
        });
    </script>
</body>

</html>